# .github/workflows/infrastructure.yml
name: Deploy Infrastructure

on:
  push:
    branches: [main]
    paths:
      - 'terraform/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches: [main]
    paths:
      - 'terraform/**'
  workflow_dispatch:
  name: Deploy Infrastructure
on:
  workflow_dispatch:
    inputs:
      env:
        description: "Deployment environment"
        required: true
        default: "dev"
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Run Terraform
        run: |
          echo "Deploying to ${{ github.event.inputs.env }}"
          terraform init
          terraform apply -auto-approve

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0

jobs:
  security-scan:
    name: Security Scanning
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Run Checkov IaC Scanner
        uses: bridgecrewio/checkov-action@master
        with:
          directory: terraform/
          framework: terraform
          output_format: sarif
          output_file_path: checkov-results.sarif
          soft_fail: true
          download_external_modules: true
      
      - name: Upload Checkov results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: checkov-results.sarif
      
      - name: Run tfsec
        uses: aquasecurity/tfsec-action@v1.0.3
        with:
          working_directory: terraform/
          format: sarif
          soft_fail: true
      
      - name: Run Terrascan
        uses: tenable/terrascan-action@v1.5.0
        with:
          iac_type: 'terraform'
          iac_dir: 'terraform/'
          policy_type: 'aws'
          sarif_upload: true
      
      - name: Comment PR with scan results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## Security Scan Results\n\nCheckov, tfsec, and Terrascan scans completed. Check workflow logs for details.'
            })

  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: security-scan
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Terraform Init
        working-directory: terraform/
        run: terraform init
      
      - name: Terraform Validate
        working-directory: terraform/
        run: terraform validate
      
      - name: Terraform Plan
        working-directory: terraform/
        run: terraform plan -out=tfplan -no-color
      
      - name: Comment PR with plan
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('terraform/tfplan.txt', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: '## Terraform Plan\n\n```terraform\n' + plan + '\n```'
            })

  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: security-scan
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Terraform Init
        working-directory: terraform/
        run: terraform init
      
      - name: Terraform Apply
        working-directory: terraform/
        run: terraform apply -auto-approve
      
      - name: Save outputs
        working-directory: terraform/
        run: |
          terraform output -json > outputs.json
          echo "MONGODB_IP=$(terraform output -raw mongodb_vm_public_ip)" >> $GITHUB_ENV
          echo "EKS_CLUSTER=$(terraform output -raw eks_cluster_name)" >> $GITHUB_ENV
      
      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER }}
      
      - name: Verify infrastructure
        run: |
          echo "MongoDB VM IP: ${{ env.MONGODB_IP }}"
          echo "EKS Cluster: ${{ env.EKS_CLUSTER }}"
          kubectl get nodes

---

# .github/workflows/application.yml
name: Build and Deploy Application

on:
  push:
    branches: [main]
    paths:
      - 'application/**'
      - 'kubernetes/**'
      - '.github/workflows/application.yml'
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
  ECR_REPOSITORY: todoapp
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build-and-scan:
    name: Build and Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./application
          load: true
          tags: todoapp:${{ env.IMAGE_TAG }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: todoapp:${{ env.IMAGE_TAG }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '0'
      
      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run Trivy in table mode
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: todoapp:${{ env.IMAGE_TAG }}
          format: 'table'
          severity: 'CRITICAL,HIGH'
      
      - name: Run Snyk container scan
        uses: snyk/actions/docker@master
        continue-on-error: true
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: todoapp:${{ env.IMAGE_TAG }}
          args: --severity-threshold=high --file=application/Dockerfile
      
      - name: Run Grype vulnerability scanner
        uses: anchore/scan-action@v3
        with:
          image: todoapp:${{ env.IMAGE_TAG }}
          fail-build: false
          severity-cutoff: high
      
      - name: Scan for secrets in image
        run: |
          docker run --rm \
            -v /var/run/docker.sock:/var/run/docker.sock \
            trufflesecurity/trufflehog:latest \
            docker --image todoapp:${{ env.IMAGE_TAG }} --json
      
      - name: Validate proexercise.txt exists
        run: |
          docker run --rm todoapp:${{ env.IMAGE_TAG }} cat /usr/src/app/proexercise.txt
          echo "✅ proexercise.txt file found in container"
      
      - name: Save image for deployment
        if: github.ref == 'refs/heads/main'
        run: |
          docker save todoapp:${{ env.IMAGE_TAG }} | gzip > todoapp.tar.gz
      
      - name: Upload image artifact
        if: github.ref == 'refs/heads/main'
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: todoapp.tar.gz
          retention-days: 1

  push-to-ecr:
    name: Push to ECR
    runs-on: ubuntu-latest
    needs: build-and-scan
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
      
      - name: Load Docker image
        run: |
          docker load < todoapp.tar.gz
      
      - name: Tag and push image to ECR
        run: |
          docker tag todoapp:${{ env.IMAGE_TAG }} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
          docker tag todoapp:${{ env.IMAGE_TAG }} ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
          docker push ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
      
      - name: Scan ECR image
        run: |
          aws ecr start-image-scan \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=${{ env.IMAGE_TAG }}

  deploy-to-k8s:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: push-to-ecr
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ secrets.EKS_CLUSTER_NAME }}
      
      - name: Install kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Create namespace if not exists
        run: |
          kubectl create namespace todoapp --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy Kubernetes manifests
        run: |
          # Update image in deployment
          sed -i "s|IMAGE_PLACEHOLDER|${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}|g" kubernetes/deployment.yaml
          
          # Apply all manifests
          kubectl apply -f kubernetes/namespace.yaml
          kubectl apply -f kubernetes/serviceaccount.yaml
          kubectl apply -f kubernetes/rbac.yaml
          kubectl apply -f kubernetes/deployment.yaml
          kubectl apply -f kubernetes/service.yaml
          kubectl apply -f kubernetes/ingress.yaml
      
      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/todoapp -n todoapp --timeout=5m
      
      - name: Verify deployment
        run: |
          kubectl get pods -n todoapp
          kubectl get svc -n todoapp
          kubectl get ingress -n todoapp
      
      - name: Run smoke tests
        run: |
          # Get LoadBalancer URL
          LB_URL=$(kubectl get svc todoapp-service -n todoapp -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          
          # Wait for LB to be ready
          echo "Waiting for load balancer to be ready..."
          for i in {1..30}; do
            if curl -sf http://$LB_URL/health > /dev/null; then
              echo "✅ Application is healthy"
              break
            fi
            echo "Attempt $i/30 failed, retrying..."
            sleep 10
          done
          
          # Test basic functionality
          curl -f http://$LB_URL || exit 1
      
      - name: Verify proexercise.txt in running pod
        run: |
          POD_NAME=$(kubectl get pods -n todoapp -l app=todoapp -o jsonpath='{.items[0].metadata.name}')
          kubectl exec -n todoapp $POD_NAME -- cat /usr/src/app/proexercise.txt
          echo "✅ proexercise.txt verified in running container"
      
      - name: Check for security issues post-deployment
        run: |
          # Check for pods with privileged containers
          kubectl get pods --all-namespaces -o json | \
            jq -r '.items[] | select(.spec.containers[]?.securityContext.privileged==true) | .metadata.name'
          
          # Check for cluster-admin bindings (should find our vulnerable one)
          kubectl get clusterrolebindings -o json | \
            jq -r '.items[] | select(.roleRef.name=="cluster-admin") | .metadata.name'

  security-posture-check:
    name: Post-Deployment Security Check
    runs-on: ubuntu-latest
    needs: deploy-to-k8s
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Check Security Hub findings
        run: |
          aws securityhub get-findings \
            --filters '{"SeverityLabel":[{"Value":"CRITICAL","Comparison":"EQUALS"}],"WorkflowStatus":[{"Value":"NEW","Comparison":"EQUALS"}]}' \
            --max-results 10
      
      - name: Check GuardDuty findings
        run: |
          DETECTOR_ID=$(aws guardduty list-detectors --query 'DetectorIds[0]' --output text)
          aws guardduty list-findings --detector-id $DETECTOR_ID --max-results 10
      
      - name: Check Config compliance
        run: |
          aws configservice describe-compliance-by-config-rule \
            --compliance-types NON_COMPLIANT \
            --max-results 20

---

# .github/workflows/destroy.yml
name: Destroy Infrastructure

on:
  workflow_dispatch:
    inputs:
      confirm:
        description: 'Type "destroy" to confirm'
        required: true

jobs:
  destroy:
    name: Destroy All Resources
    runs-on: ubuntu-latest
    if: github.event.inputs.confirm == 'destroy'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1
      
      - name: Delete Kubernetes resources first
        run: |
          aws eks update-kubeconfig --region us-east-1 --name ${{ secrets.EKS_CLUSTER_NAME }}
          kubectl delete namespace todoapp --ignore-not-found=true
      
      - name: Terraform Destroy
        working-directory: terraform/
        run: |
          terraform init
          terraform destroy -auto-approve
      
      - name: Verify cleanup
        run: |
          echo "Infrastructure destroyed successfully"
          echo "Please manually verify in AWS Console that all resources are removed"
